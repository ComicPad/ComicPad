const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-D9pJbxvs.js","assets/hedera-DH14tgdt.js","assets/vendor-CGQ6mEXs.js"])))=>i.map(i=>d[i]);
import{q as ps,J as hs,e as ds,p as us,I as gs,t as ms,j as qe,V as ys,E as fs,H as ws,B as I,C as vs,a as k,G as Ne,o as pe,i as _s,y as se,b as Is,c as Es,U as Ss,d as St,f as he,R as ve,r as bs,g as Rs,h as q,Y as qs,_ as K,N as Ps,$ as O,A as _e,k as G,n as de,z as Q,l as Ce,m as ie,s as Os,T as Ts,u as re,v as ne,W as Ns,w as He,x as Ye,Z as As,D as Xe,F as Ls,K as Ie,L as xs,M as Ve,O as bt,P as Rt,Q as qt,S as Pt,X as Ot,a0 as Tt,a1 as ue,a2 as Ae,a3 as Ze,a4 as ks,a5 as Nt,a6 as Ms,a7 as Ds,a8 as Cs,a9 as Le,aa as J,ab as ge,ac as Vs,ad as At,ae as $s,af as et,ag as Lt,ah as js,ai as Us,aj as Ws,ak as xt,al as Ks,am as zs,an as Fs,ao as Gs,ap as Qs,aq as Js,ar as kt,as as Bs,at as Hs,au as Ys,av as Xs,aw as Zs,ax as ei,ay as Mt,az as ti,aA as Dt,aB as Ct,aC as si,aD as ii,aE as ri}from"./hedera-DH14tgdt.js";const ni="modulepreload",ai=function(i){return"/"+i},Vt={},oi=function(r,e,t){let s=Promise.resolve();if(e&&e.length>0){document.getElementsByTagName("link");const c=document.querySelector("meta[property=csp-nonce]"),a=(c==null?void 0:c.nonce)||(c==null?void 0:c.getAttribute("nonce"));s=Promise.allSettled(e.map(l=>{if(l=ai(l),l in Vt)return;Vt[l]=!0;const o=l.endsWith(".css"),d=o?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${d}`))return;const h=document.createElement("link");if(h.rel=o?"stylesheet":ni,o||(h.as="script"),h.crossOrigin="",h.href=l,a&&h.setAttribute("nonce",a),document.head.appendChild(h),o)return new Promise((y,u)=>{h.addEventListener("load",y),h.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${l}`)))})}))}function n(c){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=c,window.dispatchEvent(a),!a.defaultPrevented)throw c}return s.then(c=>{for(const a of c||[])a.status==="rejected"&&n(a.reason);return r().catch(n)})},ci=Symbol(),$t=Object.getPrototypeOf,ot=new WeakMap,li=i=>i&&(ot.has(i)?ot.get(i):$t(i)===Object.prototype||$t(i)===Array.prototype),pi=i=>li(i)&&i[ci]||null,jt=(i,r=!0)=>{ot.set(i,r)},ze={},tt=i=>typeof i=="object"&&i!==null,ae=new WeakMap,$e=new WeakSet,hi=(i=Object.is,r=(o,d)=>new Proxy(o,d),e=o=>tt(o)&&!$e.has(o)&&(Array.isArray(o)||!(Symbol.iterator in o))&&!(o instanceof WeakMap)&&!(o instanceof WeakSet)&&!(o instanceof Error)&&!(o instanceof Number)&&!(o instanceof Date)&&!(o instanceof String)&&!(o instanceof RegExp)&&!(o instanceof ArrayBuffer),t=o=>{switch(o.status){case"fulfilled":return o.value;case"rejected":throw o.reason;default:throw o}},s=new WeakMap,n=(o,d,h=t)=>{const y=s.get(o);if((y==null?void 0:y[0])===d)return y[1];const u=Array.isArray(o)?[]:Object.create(Object.getPrototypeOf(o));return jt(u,!0),s.set(o,[d,u]),Reflect.ownKeys(o).forEach(f=>{if(Object.getOwnPropertyDescriptor(u,f))return;const m=Reflect.get(o,f),g={value:m,enumerable:!0,configurable:!0};if($e.has(m))jt(m,!1);else if(m instanceof Promise)delete g.value,g.get=()=>h(m);else if(ae.has(m)){const[_,S]=ae.get(m);g.value=n(_,S(),h)}Object.defineProperty(u,f,g)}),Object.preventExtensions(u)},c=new WeakMap,a=[1,1],l=o=>{if(!tt(o))throw new Error("object required");const d=c.get(o);if(d)return d;let h=a[0];const y=new Set,u=(w,v=++a[0])=>{h!==v&&(h=v,y.forEach(E=>E(w,v)))};let f=a[1];const m=(w=++a[1])=>(f!==w&&!y.size&&(f=w,_.forEach(([v])=>{const E=v[1](w);E>h&&(h=E)})),h),g=w=>(v,E)=>{const L=[...v];L[1]=[w,...L[1]],u(L,E)},_=new Map,S=(w,v)=>{if((ze?"production":void 0)!=="production"&&_.has(w))throw new Error("prop listener already exists");if(y.size){const E=v[3](g(w));_.set(w,[v,E])}else _.set(w,[v])},R=w=>{var v;const E=_.get(w);E&&(_.delete(w),(v=E[1])==null||v.call(E))},A=w=>(y.add(w),y.size===1&&_.forEach(([E,L],W)=>{if((ze?"production":void 0)!=="production"&&L)throw new Error("remove already exists");const F=E[3](g(W));_.set(W,[E,F])}),()=>{y.delete(w),y.size===0&&_.forEach(([E,L],W)=>{L&&(L(),_.set(W,[E]))})}),N=Array.isArray(o)?[]:Object.create(Object.getPrototypeOf(o)),x=r(N,{deleteProperty(w,v){const E=Reflect.get(w,v);R(v);const L=Reflect.deleteProperty(w,v);return L&&u(["delete",[v],E]),L},set(w,v,E,L){const W=Reflect.has(w,v),F=Reflect.get(w,v,L);if(W&&(i(F,E)||c.has(E)&&i(F,c.get(E))))return!0;R(v),tt(E)&&(E=pi(E)||E);let H=E;if(E instanceof Promise)E.then(U=>{E.status="fulfilled",E.value=U,u(["resolve",[v],U])}).catch(U=>{E.status="rejected",E.reason=U,u(["reject",[v],U])});else{!ae.has(E)&&e(E)&&(H=l(E));const U=!$e.has(H)&&ae.get(H);U&&S(v,U)}return Reflect.set(w,v,H,L),u(["set",[v],E,F]),!0}});c.set(o,x);const ee=[N,m,n,A];return ae.set(x,ee),Reflect.ownKeys(o).forEach(w=>{const v=Object.getOwnPropertyDescriptor(o,w);"value"in v&&(x[w]=o[w],delete v.value,delete v.writable),Object.defineProperty(N,w,v)}),x})=>[l,ae,$e,i,r,e,t,s,n,c,a],[di]=hi();function ce(i={}){return di(i)}function we(i,r,e){const t=ae.get(i);(ze?"production":void 0)!=="production"&&!t&&console.warn("Please use proxy object");let s;const n=[],c=t[3];let a=!1;const o=c(d=>{n.push(d),s||(s=Promise.resolve().then(()=>{s=void 0,a&&r(n.splice(0))}))});return a=!0,()=>{a=!1,o()}}function ui(i,r){const e=ae.get(i);(ze?"production":void 0)!=="production"&&!e&&console.warn("Please use proxy object");const[t,s,n]=e;return n(t,s(),r)}const M=ce({history:["ConnectWallet"],view:"ConnectWallet",data:void 0}),ts={state:M,subscribe(i){return we(M,()=>i(M))},push(i,r){i!==M.view&&(M.view=i,r&&(M.data=r),M.history.push(i))},reset(i){M.view=i,M.history=[i]},replace(i){M.history.length>1&&(M.history[M.history.length-1]=i,M.view=i)},goBack(){if(M.history.length>1){M.history.pop();const[i]=M.history.slice(-1);M.view=i}},setData(i){M.data=i}},j={WALLETCONNECT_DEEPLINK_CHOICE:"WALLETCONNECT_DEEPLINK_CHOICE",WCM_VERSION:"WCM_VERSION",RECOMMENDED_WALLET_AMOUNT:9,isMobile(){return typeof window<"u"?!!(window.matchMedia("(pointer:coarse)").matches||/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)):!1},isAndroid(){return j.isMobile()&&navigator.userAgent.toLowerCase().includes("android")},isIos(){const i=navigator.userAgent.toLowerCase();return j.isMobile()&&(i.includes("iphone")||i.includes("ipad"))},isHttpUrl(i){return i.startsWith("http://")||i.startsWith("https://")},isArray(i){return Array.isArray(i)&&i.length>0},isTelegram(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)},formatNativeUrl(i,r,e){if(j.isHttpUrl(i))return this.formatUniversalUrl(i,r,e);let t=i;t.includes("://")||(t=i.replaceAll("/","").replaceAll(":",""),t=`${t}://`),t.endsWith("/")||(t=`${t}/`),this.setWalletConnectDeepLink(t,e);const s=encodeURIComponent(r);return`${t}wc?uri=${s}`},formatUniversalUrl(i,r,e){if(!j.isHttpUrl(i))return this.formatNativeUrl(i,r,e);let t=i;if(t.startsWith("https://t.me")){const n=Buffer.from(r).toString("base64").replace(/[=]/g,"");t.endsWith("/")&&(t=t.slice(0,-1)),this.setWalletConnectDeepLink(t,e);const c=new URL(t);return c.searchParams.set("startapp",n),c.toString()}t.endsWith("/")||(t=`${t}/`),this.setWalletConnectDeepLink(t,e);const s=encodeURIComponent(r);return`${t}wc?uri=${s}`},async wait(i){return new Promise(r=>{setTimeout(r,i)})},openHref(i,r){const e=this.isTelegram()?"_blank":r;window.open(i,e,"noreferrer noopener")},setWalletConnectDeepLink(i,r){try{localStorage.setItem(j.WALLETCONNECT_DEEPLINK_CHOICE,JSON.stringify({href:i,name:r}))}catch{console.info("Unable to set WalletConnect deep link")}},setWalletConnectAndroidDeepLink(i){try{const[r]=i.split("?");localStorage.setItem(j.WALLETCONNECT_DEEPLINK_CHOICE,JSON.stringify({href:r,name:"Android"}))}catch{console.info("Unable to set WalletConnect android deep link")}},removeWalletConnectDeepLink(){try{localStorage.removeItem(j.WALLETCONNECT_DEEPLINK_CHOICE)}catch{console.info("Unable to remove WalletConnect deep link")}},setModalVersionInStorage(){try{typeof localStorage<"u"&&localStorage.setItem(j.WCM_VERSION,"2.7.0")}catch{console.info("Unable to set Web3Modal version in storage")}},getWalletRouterData(){var i;const r=(i=ts.state.data)==null?void 0:i.Wallet;if(!r)throw new Error('Missing "Wallet" view data');return r}},gi=typeof location<"u"&&(location.hostname.includes("localhost")||location.protocol.includes("https")),$=ce({enabled:gi,userSessionId:"",events:[],connectedWalletId:void 0}),mi={state:$,subscribe(i){return we($.events,()=>i(ui($.events[$.events.length-1])))},initialize(){$.enabled&&typeof(crypto==null?void 0:crypto.randomUUID)<"u"&&($.userSessionId=crypto.randomUUID())},setConnectedWalletId(i){$.connectedWalletId=i},click(i){if($.enabled){const r={type:"CLICK",name:i.name,userSessionId:$.userSessionId,timestamp:Date.now(),data:i};$.events.push(r)}},track(i){if($.enabled){const r={type:"TRACK",name:i.name,userSessionId:$.userSessionId,timestamp:Date.now(),data:i};$.events.push(r)}},view(i){if($.enabled){const r={type:"VIEW",name:i.name,userSessionId:$.userSessionId,timestamp:Date.now(),data:i};$.events.push(r)}}},Y=ce({chains:void 0,walletConnectUri:void 0,isAuth:!1,isCustomDesktop:!1,isCustomMobile:!1,isDataLoaded:!1,isUiLoaded:!1}),B={state:Y,subscribe(i){return we(Y,()=>i(Y))},setChains(i){Y.chains=i},setWalletConnectUri(i){Y.walletConnectUri=i},setIsCustomDesktop(i){Y.isCustomDesktop=i},setIsCustomMobile(i){Y.isCustomMobile=i},setIsDataLoaded(i){Y.isDataLoaded=i},setIsUiLoaded(i){Y.isUiLoaded=i},setIsAuth(i){Y.isAuth=i}},je=ce({projectId:"",mobileWallets:void 0,desktopWallets:void 0,walletImages:void 0,chains:void 0,enableAuthMode:!1,enableExplorer:!0,explorerExcludedWalletIds:void 0,explorerRecommendedWalletIds:void 0,termsOfServiceUrl:void 0,privacyPolicyUrl:void 0}),Re={state:je,subscribe(i){return we(je,()=>i(je))},setConfig(i){var r,e;mi.initialize(),B.setChains(i.chains),B.setIsAuth(!!i.enableAuthMode),B.setIsCustomMobile(!!((r=i.mobileWallets)!=null&&r.length)),B.setIsCustomDesktop(!!((e=i.desktopWallets)!=null&&e.length)),j.setModalVersionInStorage(),Object.assign(je,i)}};var yi=Object.defineProperty,Ut=Object.getOwnPropertySymbols,fi=Object.prototype.hasOwnProperty,wi=Object.prototype.propertyIsEnumerable,Wt=(i,r,e)=>r in i?yi(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,vi=(i,r)=>{for(var e in r||(r={}))fi.call(r,e)&&Wt(i,e,r[e]);if(Ut)for(var e of Ut(r))wi.call(r,e)&&Wt(i,e,r[e]);return i};const ct="https://explorer-api.walletconnect.com",lt="wcm",pt="js-2.7.0";async function Ue(i,r){const e=vi({sdkType:lt,sdkVersion:pt},r),t=new URL(i,ct);return t.searchParams.append("projectId",Re.state.projectId),Object.entries(e).forEach(([n,c])=>{c&&t.searchParams.append(n,String(c))}),(await fetch(t)).json()}const me={async getDesktopListings(i){return Ue("/w3m/v1/getDesktopListings",i)},async getMobileListings(i){return Ue("/w3m/v1/getMobileListings",i)},async getInjectedListings(i){return Ue("/w3m/v1/getInjectedListings",i)},async getAllListings(i){return Ue("/w3m/v1/getAllListings",i)},getWalletImageUrl(i){return`${ct}/w3m/v1/getWalletImage/${i}?projectId=${Re.state.projectId}&sdkType=${lt}&sdkVersion=${pt}`},getAssetImageUrl(i){return`${ct}/w3m/v1/getAssetImage/${i}?projectId=${Re.state.projectId}&sdkType=${lt}&sdkVersion=${pt}`}};var _i=Object.defineProperty,Kt=Object.getOwnPropertySymbols,Ii=Object.prototype.hasOwnProperty,Ei=Object.prototype.propertyIsEnumerable,zt=(i,r,e)=>r in i?_i(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,Si=(i,r)=>{for(var e in r||(r={}))Ii.call(r,e)&&zt(i,e,r[e]);if(Kt)for(var e of Kt(r))Ei.call(r,e)&&zt(i,e,r[e]);return i};const Ft=j.isMobile(),X=ce({wallets:{listings:[],total:0,page:1},search:{listings:[],total:0,page:1},recomendedWallets:[]}),Ir={state:X,async getRecomendedWallets(){const{explorerRecommendedWalletIds:i,explorerExcludedWalletIds:r}=Re.state;if(i==="NONE"||r==="ALL"&&!i)return X.recomendedWallets;if(j.isArray(i)){const t={recommendedIds:i.join(",")},{listings:s}=await me.getAllListings(t),n=Object.values(s);n.sort((c,a)=>{const l=i.indexOf(c.id),o=i.indexOf(a.id);return l-o}),X.recomendedWallets=n}else{const{chains:e,isAuth:t}=B.state,s=e==null?void 0:e.join(","),n=j.isArray(r),c={page:1,sdks:t?"auth_v1":void 0,entries:j.RECOMMENDED_WALLET_AMOUNT,chains:s,version:2,excludedIds:n?r.join(","):void 0},{listings:a}=Ft?await me.getMobileListings(c):await me.getDesktopListings(c);X.recomendedWallets=Object.values(a)}return X.recomendedWallets},async getWallets(i){const r=Si({},i),{explorerRecommendedWalletIds:e,explorerExcludedWalletIds:t}=Re.state,{recomendedWallets:s}=X;if(t==="ALL")return X.wallets;s.length?r.excludedIds=s.map(h=>h.id).join(","):j.isArray(e)&&(r.excludedIds=e.join(",")),j.isArray(t)&&(r.excludedIds=[r.excludedIds,t].filter(Boolean).join(",")),B.state.isAuth&&(r.sdks="auth_v1");const{page:n,search:c}=i,{listings:a,total:l}=Ft?await me.getMobileListings(r):await me.getDesktopListings(r),o=Object.values(a),d=c?"search":"wallets";return X[d]={listings:[...X[d].listings,...o],total:l,page:n??1},{listings:o,total:l}},getWalletImageUrl(i){return me.getWalletImageUrl(i)},getAssetImageUrl(i){return me.getAssetImageUrl(i)},resetSearch(){X.search={listings:[],total:0,page:1}}},Ee=ce({open:!1}),st={state:Ee,subscribe(i){return we(Ee,()=>i(Ee))},async open(i){return new Promise(r=>{const{isUiLoaded:e,isDataLoaded:t}=B.state;if(j.removeWalletConnectDeepLink(),B.setWalletConnectUri(i==null?void 0:i.uri),B.setChains(i==null?void 0:i.chains),ts.reset("ConnectWallet"),e&&t)Ee.open=!0,r();else{const s=setInterval(()=>{const n=B.state;n.isUiLoaded&&n.isDataLoaded&&(clearInterval(s),Ee.open=!0,r())},200)}})},close(){Ee.open=!1}};var bi=Object.defineProperty,Gt=Object.getOwnPropertySymbols,Ri=Object.prototype.hasOwnProperty,qi=Object.prototype.propertyIsEnumerable,Qt=(i,r,e)=>r in i?bi(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,Pi=(i,r)=>{for(var e in r||(r={}))Ri.call(r,e)&&Qt(i,e,r[e]);if(Gt)for(var e of Gt(r))qi.call(r,e)&&Qt(i,e,r[e]);return i};function Oi(){return typeof matchMedia<"u"&&matchMedia("(prefers-color-scheme: dark)").matches}const xe=ce({themeMode:Oi()?"dark":"light"}),Jt={state:xe,subscribe(i){return we(xe,()=>i(xe))},setThemeConfig(i){const{themeMode:r,themeVariables:e}=i;r&&(xe.themeMode=r),e&&(xe.themeVariables=Pi({},e))}},ye=ce({open:!1,message:"",variant:"success"}),Er={state:ye,subscribe(i){return we(ye,()=>i(ye))},openToast(i,r){ye.open=!0,ye.message=i,ye.variant=r},closeToast(){ye.open=!1}};class Sr{constructor(r){this.openModal=st.open,this.closeModal=st.close,this.subscribeModal=st.subscribe,this.setTheme=Jt.setThemeConfig,Jt.setThemeConfig(r),Re.setConfig(r),this.initUi()}async initUi(){if(typeof window<"u"){await oi(()=>import("./index-D9pJbxvs.js"),__vite__mapDeps([0,1,2]));const r=document.createElement("wcm-modal");document.body.insertAdjacentElement("beforeend",r),B.setIsUiLoaded(!0)}}}var gt={exports:{}};const Bt=ps;gt.exports=te;const ke=Ki().console||{},Ti={mapHttpRequest:We,mapHttpResponse:We,wrapRequestSerializer:it,wrapResponseSerializer:it,wrapErrorSerializer:it,req:We,res:We,err:Yt,errWithCause:Yt};function oe(i,r){return i==="silent"?1/0:r.levels.values[i]}const mt=Symbol("pino.logFuncs"),ht=Symbol("pino.hierarchy"),Ni={error:"log",fatal:"error",warn:"error",info:"log",debug:"log",trace:"log"};function Ht(i,r){const e={logger:r,parent:i[ht]};r[ht]=e}function Ai(i,r,e){const t={};r.forEach(s=>{t[s]=e[s]?e[s]:ke[s]||ke[Ni[s]||"log"]||be}),i[mt]=t}function Li(i,r){return Array.isArray(i)?i.filter(function(t){return t!=="!stdSerializers.err"}):i===!0?Object.keys(r):!1}function te(i){i=i||{},i.browser=i.browser||{};const r=i.browser.transmit;if(r&&typeof r.send!="function")throw Error("pino: transmit option must have a send function");const e=i.browser.write||ke;i.browser.write&&(i.browser.asObject=!0);const t=i.serializers||{},s=Li(i.browser.serialize,t);let n=i.browser.serialize;Array.isArray(i.browser.serialize)&&i.browser.serialize.indexOf("!stdSerializers.err")>-1&&(n=!1);const c=Object.keys(i.customLevels||{}),a=["error","fatal","warn","info","debug","trace"].concat(c);typeof e=="function"&&a.forEach(function(m){e[m]=e}),(i.enabled===!1||i.browser.disabled)&&(i.level="silent");const l=i.level||"info",o=Object.create(e);o.log||(o.log=be),Ai(o,a,e),Ht({},o),Object.defineProperty(o,"levelVal",{get:h}),Object.defineProperty(o,"level",{get:y,set:u});const d={transmit:r,serialize:s,asObject:i.browser.asObject,asObjectBindingsOnly:i.browser.asObjectBindingsOnly,formatters:i.browser.formatters,levels:a,timestamp:ji(i),messageKey:i.messageKey||"msg",onChild:i.onChild||be};o.levels=xi(i),o.level=l,o.isLevelEnabled=function(m){return this.levels.values[m]?this.levels.values[m]>=this.levels.values[this.level]:!1},o.setMaxListeners=o.getMaxListeners=o.emit=o.addListener=o.on=o.prependListener=o.once=o.prependOnceListener=o.removeListener=o.removeAllListeners=o.listeners=o.listenerCount=o.eventNames=o.write=o.flush=be,o.serializers=t,o._serialize=s,o._stdErrSerialize=n,o.child=function(...m){return f.call(this,d,...m)},r&&(o._logEvent=dt());function h(){return oe(this.level,this)}function y(){return this._level}function u(m){if(m!=="silent"&&!this.levels.values[m])throw Error("unknown level "+m);this._level=m,fe(this,d,o,"error"),fe(this,d,o,"fatal"),fe(this,d,o,"warn"),fe(this,d,o,"info"),fe(this,d,o,"debug"),fe(this,d,o,"trace"),c.forEach(g=>{fe(this,d,o,g)})}function f(m,g,_){if(!g)throw new Error("missing bindings for child Pino");_=_||{},s&&g.serializers&&(_.serializers=g.serializers);const S=_.serializers;if(s&&S){var R=Object.assign({},t,S),A=i.browser.serialize===!0?Object.keys(R):s;delete g.serializers,yt([g],A,R,this._stdErrSerialize)}function N(x){this._childLevel=(x._childLevel|0)+1,this.bindings=g,R&&(this.serializers=R,this._serialize=A),r&&(this._logEvent=dt([].concat(x._logEvent.bindings,g)))}N.prototype=this;const T=new N(this);return Ht(this,T),T.child=function(...x){return f.call(this,m,...x)},T.level=_.level||this.level,m.onChild(T),T}return o}function xi(i){const r=i.customLevels||{},e=Object.assign({},te.levels.values,r),t=Object.assign({},te.levels.labels,ki(r));return{values:e,labels:t}}function ki(i){const r={};return Object.keys(i).forEach(function(e){r[i[e]]=e}),r}te.levels={values:{fatal:60,error:50,warn:40,info:30,debug:20,trace:10},labels:{10:"trace",20:"debug",30:"info",40:"warn",50:"error",60:"fatal"}};te.stdSerializers=Ti;te.stdTimeFunctions=Object.assign({},{nullTime:ss,epochTime:is,unixTime:Ui,isoTime:Wi});function Mi(i){const r=[];i.bindings&&r.push(i.bindings);let e=i[ht];for(;e.parent;)e=e.parent,e.logger.bindings&&r.push(e.logger.bindings);return r.reverse()}function fe(i,r,e,t){if(Object.defineProperty(i,t,{value:oe(i.level,e)>oe(t,e)?be:e[mt][t],writable:!0,enumerable:!0,configurable:!0}),i[t]===be){if(!r.transmit)return;const n=r.transmit.level||i.level,c=oe(n,e);if(oe(t,e)<c)return}i[t]=Ci(i,r,e,t);const s=Mi(i);s.length!==0&&(i[t]=Di(s,i[t]))}function Di(i,r){return function(){return r.apply(this,[...i,...arguments])}}function Ci(i,r,e,t){return function(s){return function(){const c=r.timestamp(),a=new Array(arguments.length),l=Object.getPrototypeOf&&Object.getPrototypeOf(this)===ke?ke:this;for(var o=0;o<a.length;o++)a[o]=arguments[o];var d=!1;if(r.serialize&&(yt(a,this._serialize,this.serializers,this._stdErrSerialize),d=!0),r.asObject||r.formatters?s.call(l,...Vi(this,t,a,c,r)):s.apply(l,a),r.transmit){const h=r.transmit.level||i._level,y=oe(h,e),u=oe(t,e);if(u<y)return;$i(this,{ts:c,methodLevel:t,methodValue:u,transmitValue:e.levels.values[r.transmit.level||i._level],send:r.transmit.send,val:oe(i._level,e)},a,d)}}}(i[mt][t])}function Vi(i,r,e,t,s){const{level:n,log:c=h=>h}=s.formatters||{},a=e.slice();let l=a[0];const o={};let d=(i._childLevel|0)+1;if(d<1&&(d=1),t&&(o.time=t),n){const h=n(r,i.levels.values[r]);Object.assign(o,h)}else o.level=i.levels.values[r];if(s.asObjectBindingsOnly){if(l!==null&&typeof l=="object")for(;d--&&typeof a[0]=="object";)Object.assign(o,a.shift());return[c(o),...a]}else{if(l!==null&&typeof l=="object"){for(;d--&&typeof a[0]=="object";)Object.assign(o,a.shift());l=a.length?Bt(a.shift(),a):void 0}else typeof l=="string"&&(l=Bt(a.shift(),a));return l!==void 0&&(o[s.messageKey]=l),[c(o)]}}function yt(i,r,e,t){for(const s in i)if(t&&i[s]instanceof Error)i[s]=te.stdSerializers.err(i[s]);else if(typeof i[s]=="object"&&!Array.isArray(i[s])&&r)for(const n in i[s])r.indexOf(n)>-1&&n in e&&(i[s][n]=e[n](i[s][n]))}function $i(i,r,e,t=!1){const s=r.send,n=r.ts,c=r.methodLevel,a=r.methodValue,l=r.val,o=i._logEvent.bindings;t||yt(e,i._serialize||Object.keys(i.serializers),i.serializers,i._stdErrSerialize===void 0?!0:i._stdErrSerialize),i._logEvent.ts=n,i._logEvent.messages=e.filter(function(d){return o.indexOf(d)===-1}),i._logEvent.level.label=c,i._logEvent.level.value=a,s(c,i._logEvent,l),i._logEvent=dt(o)}function dt(i){return{ts:0,messages:[],bindings:i||[],level:{label:"",value:0}}}function Yt(i){const r={type:i.constructor.name,msg:i.message,stack:i.stack};for(const e in i)r[e]===void 0&&(r[e]=i[e]);return r}function ji(i){return typeof i.timestamp=="function"?i.timestamp:i.timestamp===!1?ss:is}function We(){return{}}function it(i){return i}function be(){}function ss(){return!1}function is(){return Date.now()}function Ui(){return Math.round(Date.now()/1e3)}function Wi(){return new Date(Date.now()).toISOString()}function Ki(){function i(r){return typeof r<"u"&&r}try{return typeof globalThis<"u"||Object.defineProperty(Object.prototype,"globalThis",{get:function(){return delete Object.prototype.globalThis,this.globalThis=this},configurable:!0}),globalThis}catch{return i(self)||i(window)||i(this)||{}}}gt.exports.default=te;gt.exports.pino=te;const zi="custom_context";function Fi(i,r=zi){return i[r]||""}const rs="wc",ns=2,as="client",ft=`${rs}@${ns}:${as}:`,rt={name:as,logger:"error"},Xt="WALLETCONNECT_DEEPLINK_CHOICE",Gi="proposal",Zt="Proposal expired",Qi="session",Se=q.SEVEN_DAYS,Ji="engine",D={wc_sessionPropose:{req:{ttl:q.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:q.ONE_DAY,prompt:!1,tag:1104},res:{ttl:q.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:q.ONE_DAY,prompt:!1,tag:1106},res:{ttl:q.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:q.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:q.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:q.ONE_DAY,prompt:!1,tag:1112},res:{ttl:q.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:q.ONE_DAY,prompt:!1,tag:1114},res:{ttl:q.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:q.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:q.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:q.FIVE_MINUTES,prompt:!1,tag:1119}}},nt={min:q.FIVE_MINUTES,max:q.SEVEN_DAYS},Z={idle:"IDLE",active:"ACTIVE"},Bi={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"},sui_signAndExecuteTransaction:{key:"digest"},sui_signTransaction:{key:""},hedera_signAndExecuteTransaction:{key:"transactionId"},hedera_executeTransaction:{key:"transactionId"},near_signTransaction:{key:""},near_signTransactions:{key:""},tron_signTransaction:{key:"txID"},xrpl_signTransaction:{key:""},xrpl_signTransactionFor:{key:""},algo_signTxn:{key:""},sendTransfer:{key:"txid"},stacks_stxTransfer:{key:"txId"},polkadot_signTransaction:{key:""},cosmos_signDirect:{key:""}},Hi="request",Yi=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Xi="wc",Zi="auth",er="authKeys",tr="pairingTopics",sr="requests",Fe=`${Xi}@${1.5}:${Zi}:`,Ke=`${Fe}:PUB_KEY`;var ir=Object.defineProperty,rr=Object.defineProperties,nr=Object.getOwnPropertyDescriptors,es=Object.getOwnPropertySymbols,ar=Object.prototype.hasOwnProperty,or=Object.prototype.propertyIsEnumerable,ut=(i,r,e)=>r in i?ir(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,P=(i,r)=>{for(var e in r||(r={}))ar.call(r,e)&&ut(i,e,r[e]);if(es)for(var e of es(r))or.call(r,e)&&ut(i,e,r[e]);return i},C=(i,r)=>rr(i,nr(r)),p=(i,r,e)=>ut(i,typeof r!="symbol"?r+"":r,e);class cr extends ys{constructor(r){super(r),p(this,"name",Ji),p(this,"events",new fs),p(this,"initialized",!1),p(this,"requestQueue",{state:Z.idle,queue:[]}),p(this,"sessionRequestQueue",{state:Z.idle,queue:[]}),p(this,"emittedSessionRequests",new ws({limit:500})),p(this,"requestQueueDelay",q.ONE_SECOND),p(this,"expectedPairingMethodMap",new Map),p(this,"recentlyDeletedMap",new Map),p(this,"recentlyDeletedLimit",200),p(this,"relayMessageCache",[]),p(this,"pendingSessions",new Map),p(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(D)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},q.toMiliseconds(this.requestQueueDelay)))}),p(this,"connect",async e=>{var t;this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=C(P({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s),s.optionalNamespaces=qs(s.requiredNamespaces,s.optionalNamespaces),s.requiredNamespaces={};const{pairingTopic:n,requiredNamespaces:c,optionalNamespaces:a,sessionProperties:l,scopedProperties:o,relays:d,authentication:h,walletPay:y}=s,u=((t=h==null?void 0:h[0])==null?void 0:t.ttl)||D.wc_sessionPropose.req.ttl||q.FIVE_MINUTES;this.validateRequestExpiry(u);let f=n,m,g=!1;try{if(f){const w=this.client.core.pairing.pairings.get(f);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),g=w.active}}catch(w){throw this.client.logger.error(`connect() -> pairing.get(${f}) failed`),w}if(!f||!g){const{topic:w,uri:v}=await this.client.core.pairing.create({internal:{skipSubscribe:!0}});f=w,m=v}if(!f){const{message:w}=I("NO_MATCHING_KEY",`connect() pairing topic: ${f}`);throw new Error(w)}const _=await this.client.core.crypto.generateKeyPair(),S=K(u),R=P(C(P(P({requiredNamespaces:c,optionalNamespaces:a,relays:d??[{protocol:Ps}],proposer:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:S,pairingTopic:f},l&&{sessionProperties:l}),o&&{scopedProperties:o}),{id:ie()}),(h||y)&&{requests:{authentication:h==null?void 0:h.map(w=>{const{domain:v,chains:E,nonce:L,uri:W,exp:F,nbf:H,type:U,statement:Pe,requestId:Me,resources:V,signatureTypes:z}=w;return{domain:v,chains:E,nonce:L,type:U??"caip122",aud:W,version:"1",iat:new Date().toISOString(),exp:F,nbf:H,statement:Pe,requestId:Me,resources:V,signatureTypes:z}}),walletPay:y}}),A=O("session_connect",R.id),{reject:N,resolve:T,done:x}=_e(u,Zt),ee=({id:w})=>{w===R.id&&(this.client.events.off("proposal_expire",ee),this.pendingSessions.delete(R.id),this.events.emit(A,{error:{message:Zt,code:0}}))};return this.client.events.on("proposal_expire",ee),this.events.once(A,({error:w,session:v})=>{this.client.events.off("proposal_expire",ee),w?N(w):v&&T(v)}),await this.setProposal(R.id,R),await this.sendProposeSession({proposal:R,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:{correlationId:R.id}}}).catch(w=>{throw this.deleteProposal(R.id),w}),{uri:m,approval:x}}),p(this,"pair",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}}),p(this,"approve",async e=>{var t,s,n;const c=this.client.core.eventClient.createEvent({properties:{topic:(t=e==null?void 0:e.id)==null?void 0:t.toString(),trace:[G.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(v){throw c.setError(de.no_internet_connection),v}try{await this.isValidProposalId(e==null?void 0:e.id)}catch(v){throw this.client.logger.error(`approve() -> proposal.get(${e==null?void 0:e.id}) failed`),c.setError(de.proposal_not_found),v}try{await this.isValidApprove(e)}catch(v){throw this.client.logger.error("approve() -> isValidApprove() failed"),c.setError(de.session_approve_namespace_validation_failure),v}const{id:a,relayProtocol:l,namespaces:o,sessionProperties:d,scopedProperties:h,sessionConfig:y,proposalRequestsResponses:u}=e,f=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:c.eventId});const{pairingTopic:m,proposer:g,requiredNamespaces:_,optionalNamespaces:S}=f;let R=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:m});R||(R=(n=this.client.core.eventClient)==null?void 0:n.createEvent({type:G.session_approve_started,properties:{topic:m,trace:[G.session_approve_started,G.session_namespaces_validation_success]}}));const A=await this.client.core.crypto.generateKeyPair(),N=g.publicKey,T=await this.client.core.crypto.generateSharedKey(A,N),x=C(P(P(P({relay:{protocol:l??"irn"},namespaces:o,controller:{publicKey:A,metadata:this.client.metadata},expiry:K(Se)},d&&{sessionProperties:d}),h&&{scopedProperties:h}),y&&{sessionConfig:y}),{proposalRequestsResponses:u}),ee=k.relay;R.addTrace(G.subscribing_session_topic);try{await this.client.core.relayer.subscribe(T,{transportType:ee,internal:{skipSubscribe:!0}})}catch(v){throw R.setError(de.subscribe_session_topic_failure),v}R.addTrace(G.subscribe_session_topic_success);const w=C(P({},x),{topic:T,requiredNamespaces:_,optionalNamespaces:S,pairingTopic:m,acknowledged:!1,self:x.controller,peer:{publicKey:g.publicKey,metadata:g.metadata},controller:A,transportType:k.relay,authentication:u==null?void 0:u.authentication,walletPayResult:u==null?void 0:u.walletPay});await this.client.session.set(T,w),R.addTrace(G.store_session);try{await this.sendApproveSession({sessionTopic:T,proposal:f,pairingProposalResponse:{relay:{protocol:l??"irn"},responderPublicKey:A},sessionSettleRequest:x,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:P({correlationId:a},this.getTVFApproveParams(w))}}),R.addTrace(G.session_approve_publish_success)}catch(v){throw this.client.logger.error(v),this.client.session.delete(T,Q("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(T),v}return this.client.core.eventClient.deleteEvent({eventId:R.eventId}),await this.client.core.pairing.updateMetadata({topic:m,metadata:g.metadata}),await this.deleteProposal(a),await this.client.core.pairing.activate({topic:m}),await this.setExpiry(T,K(Se)),{topic:T,acknowledged:()=>Promise.resolve(this.client.session.get(T))}}),p(this,"reject",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(c){throw this.client.logger.error("reject() -> isValidReject() failed"),c}const{id:t,reason:s}=e;let n;try{n=this.client.proposal.get(t).pairingTopic}catch(c){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),c}n&&await this.sendError({id:t,topic:n,error:s,rpcOpts:D.wc_sessionPropose.reject}),await this.deleteProposal(t)}),p(this,"update",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(h){throw this.client.logger.error("update() -> isValidUpdate() failed"),h}const{topic:t,namespaces:s}=e,{done:n,resolve:c,reject:a}=_e(q.FIVE_MINUTES,"Session update request expired without receiving any acknowledgement"),l=ie(),o=Ce().toString(),d=this.client.session.get(t).namespaces;return this.events.once(O("session_update",l),({error:h})=>{h?a(h):c()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:l,relayRpcId:o}).catch(h=>{this.client.logger.error(h),this.client.session.update(t,{namespaces:d}),a(h)}),{acknowledged:n}}),p(this,"extend",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(l){throw this.client.logger.error("extend() -> isValidExtend() failed"),l}const{topic:t}=e,s=ie(),{done:n,resolve:c,reject:a}=_e(q.FIVE_MINUTES,"Session extend request expired without receiving any acknowledgement");return this.events.once(O("session_extend",s),({error:l})=>{l?a(l):c()}),await this.setExpiry(t,K(Se)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(l=>{a(l)}),{acknowledged:n}}),p(this,"request",async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(g){throw this.client.logger.error("request() -> isValidRequest() failed"),g}const{chainId:t,request:s,topic:n,expiry:c=D.wc_sessionRequest.req.ttl}=e,a=this.client.session.get(n);(a==null?void 0:a.transportType)===k.relay&&await this.confirmOnlineStateOrThrow();const l=ie(),o=Ce().toString(),{done:d,resolve:h,reject:y}=_e(c,"Request expired. Please try again.");this.events.once(O("session_request",l),({error:g,result:_})=>{g?y(g):h(_)});const u="wc_sessionRequest",f=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);if(f)return await this.sendRequest({clientRpcId:l,relayRpcId:o,topic:n,method:u,params:{request:C(P({},s),{expiryTimestamp:K(c)}),chainId:t},expiry:c,throwOnFailedPublish:!0,appLink:f}).catch(g=>y(g)),this.client.events.emit("session_request_sent",{topic:n,request:s,chainId:t,id:l}),await d();const m={request:C(P({},s),{expiryTimestamp:K(c)}),chainId:t};return await Promise.all([new Promise(async g=>{await this.sendRequest({clientRpcId:l,relayRpcId:o,topic:n,method:u,params:m,expiry:c,throwOnFailedPublish:!0,tvf:this.getTVFParams(l,m)}).catch(_=>y(_)),this.client.events.emit("session_request_sent",{topic:n,request:s,chainId:t,id:l}),g()}),new Promise(async g=>{var _;if(!((_=a.sessionConfig)!=null&&_.disableDeepLink)){const S=await Os(this.client.core.storage,Xt);await Ts({id:l,topic:n,wcDeepLink:S})}g()}),d()]).then(g=>g[2])}),p(this,"respond",async e=>{var t,s;this.isInitialized();const n=this.client.core.eventClient.createEvent({properties:{topic:(e==null?void 0:e.topic)||((s=(t=e==null?void 0:e.response)==null?void 0:t.id)==null?void 0:s.toString()),trace:[G.session_request_response_started]}});try{await this.isValidRespond(e)}catch(h){throw n.addTrace(h==null?void 0:h.message),n.setError(de.session_request_response_validation_failure),h}n.addTrace(G.session_request_response_validation_success);const{topic:c,response:a}=e,{id:l}=a,o=this.client.session.get(c);o.transportType===k.relay&&await this.confirmOnlineStateOrThrow();const d=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);try{n.addTrace(G.session_request_response_publish_started),re(a)?await this.sendResult({id:l,topic:c,result:a.result,throwOnFailedPublish:!0,appLink:d}):ne(a)&&await this.sendError({id:l,topic:c,error:a.error,appLink:d}),this.cleanupAfterResponse(e)}catch(h){throw n.addTrace(h==null?void 0:h.message),n.setError(de.session_request_response_publish_failure),h}}),p(this,"ping",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=ie(),n=Ce().toString(),{done:c,resolve:a,reject:l}=_e(q.FIVE_MINUTES,"Ping request expired without receiving any acknowledgement");this.events.once(O("session_ping",s),({error:o})=>{o?l(o):a()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:n}),c()])}else this.client.core.pairing.pairings.keys.includes(t)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:t}))}),p(this,"emit",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:n}=e,c=Ce().toString(),a=ie();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:n},throwOnFailedPublish:!0,relayRpcId:c,clientRpcId:a})}),p(this,"disconnect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:Q("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=I("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}}),p(this,"find",e=>(this.isInitialized(),this.client.session.getAll().filter(t=>Ns(t,e)))),p(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),p(this,"authenticate",async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const n=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),c=n?k.link_mode:k.relay;c===k.relay&&await this.confirmOnlineStateOrThrow();const{chains:a,statement:l="",uri:o,domain:d,nonce:h,type:y,exp:u,nbf:f,methods:m=[],expiry:g}=e,_=[...e.resources||[]],{topic:S,uri:R}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:c});this.client.logger.info({message:"Generated new pairing",pairing:{topic:S,uri:R}});const A=await this.client.core.crypto.generateKeyPair(),N=He(A);if(await Promise.all([this.client.auth.authKeys.set(Ke,{responseTopic:N,publicKey:A}),this.client.auth.pairingTopics.set(N,{topic:N,pairingTopic:S})]),await this.client.core.relayer.subscribe(N,{transportType:c}),this.client.logger.info(`sending request to new pairing topic: ${S}`),m.length>0){const{namespace:V}=Ye(a[0]);let z=As(V,"request",m);Xe(_)&&(z=Ls(z,_.pop())),_.push(z)}const T=g&&g>D.wc_sessionAuthenticate.req.ttl?g:D.wc_sessionAuthenticate.req.ttl,x={authPayload:{type:y??"caip122",chains:a,statement:l,aud:o,domain:d,version:"1",nonce:h,iat:new Date().toISOString(),exp:u,nbf:f,resources:_},requester:{publicKey:A,metadata:this.client.metadata},expiryTimestamp:K(T)},ee={eip155:{chains:a,methods:[...new Set(["personal_sign",...m])],events:["chainChanged","accountsChanged"]}},w={requiredNamespaces:{},optionalNamespaces:ee,relays:[{protocol:"irn"}],pairingTopic:S,proposer:{publicKey:A,metadata:this.client.metadata},expiryTimestamp:K(D.wc_sessionPropose.req.ttl),id:ie()},{done:v,resolve:E,reject:L}=_e(T,"Request expired"),W=ie(),F=O("session_connect",w.id),H=O("session_request",W),U=async({error:V,session:z})=>{this.events.off(H,Pe),V?L(V):z&&E({session:z})},Pe=async V=>{var z,wt,vt;if(await this.deletePendingAuthRequest(W,{message:"fulfilled",code:0}),V.error){const Te=Q("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return V.error.code===Te.code?void 0:(this.events.off(F,U),L(V.error.message))}await this.deleteProposal(w.id),this.events.off(F,U);const{cacaos:_t,responder:le}=V.result,Ge=[],It=[];for(const Te of _t){await bt({cacao:Te,projectId:this.client.core.projectId})||(this.client.logger.error(Te,"Signature verification failed"),L(Q("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:Qe}=Te,Je=Xe(Qe.resources),Et=[Rt(Qe.iss)],cs=qt(Qe.iss);if(Je){const Be=Pt(Je),ls=Ot(Je);Ge.push(...Be),Et.push(...ls)}for(const Be of Et)It.push(`${Be}:${cs}`)}const Oe=await this.client.core.crypto.generateSharedKey(A,le.publicKey);let De;Ge.length>0&&(De={topic:Oe,acknowledged:!0,self:{publicKey:A,metadata:this.client.metadata},peer:le,controller:le.publicKey,expiry:K(Se),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:S,namespaces:Tt([...new Set(Ge)],[...new Set(It)]),transportType:c},await this.client.core.relayer.subscribe(Oe,{transportType:c}),await this.client.session.set(Oe,De),S&&await this.client.core.pairing.updateMetadata({topic:S,metadata:le.metadata}),De=this.client.session.get(Oe)),(z=this.client.metadata.redirect)!=null&&z.linkMode&&(wt=le.metadata.redirect)!=null&&wt.linkMode&&(vt=le.metadata.redirect)!=null&&vt.universal&&t&&(this.client.core.addLinkModeSupportedApp(le.metadata.redirect.universal),this.client.session.update(Oe,{transportType:k.link_mode})),E({auths:_t,session:De})};this.events.once(F,U),this.events.once(H,Pe);let Me;try{if(n){const V=Ie("wc_sessionAuthenticate",x,W);this.client.core.history.set(S,V);const z=await this.client.core.crypto.encode("",V,{type:xs,encoding:Ne});Me=Ve(t,S,z)}else await Promise.all([this.sendRequest({topic:S,method:"wc_sessionAuthenticate",params:x,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:W}),this.sendRequest({topic:S,method:"wc_sessionPropose",params:w,expiry:D.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:w.id})])}catch(V){throw this.events.off(F,U),this.events.off(H,Pe),V}return await this.setProposal(w.id,w),await this.setAuthRequest(W,{request:C(P({},x),{verifyContext:{}}),pairingTopic:S,transportType:c}),{uri:Me??R,response:v}}),p(this,"approveSessionAuthenticate",async e=>{const{id:t,auths:s}=e,n=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[ue.authenticated_session_approve_started]}});try{this.isInitialized()}catch(g){throw n.setError(Ae.no_internet_connection),g}const c=this.getPendingAuthRequest(t);if(!c)throw n.setError(Ae.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const a=c.transportType||k.relay;a===k.relay&&await this.confirmOnlineStateOrThrow();const l=c.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),d=He(l),h={type:Ze,receiverPublicKey:l,senderPublicKey:o},y=[],u=[];for(const g of s){if(!await bt({cacao:g,projectId:this.client.core.projectId})){n.setError(Ae.invalid_cacao);const N=Q("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:d,error:N,encodeOpts:h}),new Error(N.message)}n.addTrace(ue.cacaos_verified);const{p:_}=g,S=Xe(_.resources),R=[Rt(_.iss)],A=qt(_.iss);if(S){const N=Pt(S),T=Ot(S);y.push(...N),R.push(...T)}for(const N of R)u.push(`${N}:${A}`)}const f=await this.client.core.crypto.generateSharedKey(o,l);n.addTrace(ue.create_authenticated_session_topic);let m;if((y==null?void 0:y.length)>0){m={topic:f,acknowledged:!0,self:{publicKey:o,metadata:this.client.metadata},peer:{publicKey:l,metadata:c.requester.metadata},controller:l,expiry:K(Se),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:c.pairingTopic,namespaces:Tt([...new Set(y)],[...new Set(u)]),transportType:a},n.addTrace(ue.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:a})}catch(g){throw n.setError(Ae.subscribe_authenticated_session_topic_failure),g}n.addTrace(ue.subscribe_authenticated_session_topic_success),await this.client.session.set(f,m),n.addTrace(ue.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:c.pairingTopic,metadata:c.requester.metadata})}n.addTrace(ue.publishing_authenticated_session_approve);try{await this.sendResult({topic:d,id:t,result:{cacaos:s,responder:{publicKey:o,metadata:this.client.metadata}},encodeOpts:h,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(c.requester.metadata,a)})}catch(g){throw n.setError(Ae.authenticated_session_approve_publish_failure),g}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:c.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:n.eventId}),{session:m}}),p(this,"rejectSessionAuthenticate",async e=>{this.isInitialized();const{id:t,reason:s}=e,n=this.getPendingAuthRequest(t);if(!n)throw new Error(`Could not find pending auth request with id ${t}`);n.transportType===k.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),l=He(c),o={type:Ze,receiverPublicKey:c,senderPublicKey:a};await this.sendError({id:t,topic:l,error:s,encodeOpts:o,rpcOpts:D.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(n.requester.metadata,n.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.deleteProposal(t)}),p(this,"formatAuthMessage",e=>{this.isInitialized();const{request:t,iss:s}=e;return ks(t,s)}),p(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)}),p(this,"cleanupDuplicatePairings",async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(n=>{var c,a;return((c=n.peerMetadata)==null?void 0:c.url)&&((a=n.peerMetadata)==null?void 0:a.url)===e.peer.metadata.url&&n.topic&&n.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(n=>this.client.core.pairing.disconnect({topic:n.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}}),p(this,"deleteSession",async e=>{var t;const{topic:s,expirerHasDeleted:n=!1,emitEvent:c=!0,id:a=0}=e,{self:l}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,Q("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(l.publicKey)&&await this.client.core.crypto.deleteKeyPair(l.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),n||this.client.core.expirer.del(s),this.client.core.storage.removeItem(Xt).catch(o=>this.client.logger.warn(o)),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=Z.idle),await Promise.all(this.getPendingSessionRequests().filter(o=>o.topic===s).map(o=>this.deletePendingSessionRequest(o.id,Q("USER_DISCONNECTED")))),c&&this.client.events.emit("session_delete",{id:a,topic:s})}),p(this,"deleteProposal",async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),n=this.client.core.eventClient.getEvent({topic:s.pairingTopic});n==null||n.setError(de.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,Q("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")}),p(this,"deletePendingSessionRequest",async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(n=>n.id!==e),s&&(this.sessionRequestQueue.state=Z.idle,this.client.events.emit("session_request_expire",{id:e}))}),p(this,"deletePendingAuthRequest",async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])}),p(this,"setExpiry",async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))}),p(this,"setProposal",async(e,t)=>{this.client.core.expirer.set(e,K(D.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)}),p(this,"setAuthRequest",async(e,t)=>{const{request:s,pairingTopic:n,transportType:c=k.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:n,verifyContext:s.verifyContext,transportType:c})}),p(this,"setPendingSessionRequest",async e=>{const{id:t,topic:s,params:n,verifyContext:c}=e,a=n.request.expiryTimestamp||K(D.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,a),await this.client.pendingRequest.set(t,{id:t,topic:s,params:n,verifyContext:c})}),p(this,"sendRequest",async e=>{const{topic:t,method:s,params:n,expiry:c,relayRpcId:a,clientRpcId:l,throwOnFailedPublish:o,appLink:d,tvf:h,publishOpts:y={}}=e,u=Ie(s,n,l);let f;const m=!!d;try{const S=m?Ne:pe;f=await this.client.core.crypto.encode(t,u,{encoding:S})}catch(S){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),S}let g;if(Yi.includes(s)){const S=se(JSON.stringify(u)),R=se(f);g=await this.client.core.verify.register({id:R,decryptedId:S})}const _=P(P({},D[s].req),y);if(_.attestation=g,c&&(_.ttl=c),a&&(_.id=a),this.client.core.history.set(t,u),m){const S=Ve(d,t,f);await global.Linking.openURL(S,this.client.name)}else _.tvf=C(P({},h),{correlationId:u.id}),o?(_.internal=C(P({},_.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,f,_)):this.client.core.relayer.publish(t,f,_).catch(S=>this.client.logger.error(S));return u.id}),p(this,"sendProposeSession",async e=>{const{proposal:t,publishOpts:s}=e,n=Ie("wc_sessionPropose",t,t.id);this.client.core.history.set(t.pairingTopic,n);const c=await this.client.core.crypto.encode(t.pairingTopic,n,{encoding:pe}),a=se(JSON.stringify(n)),l=se(c),o=await this.client.core.verify.register({id:l,decryptedId:a});await this.client.core.relayer.publishCustom({payload:{pairingTopic:t.pairingTopic,sessionProposal:c},opts:C(P({},s),{publishMethod:"wc_proposeSession",attestation:o})})}),p(this,"sendApproveSession",async e=>{const{sessionTopic:t,pairingProposalResponse:s,proposal:n,sessionSettleRequest:c,publishOpts:a}=e,l=Nt(n.id,s),o=await this.client.core.crypto.encode(n.pairingTopic,l,{encoding:pe}),d=Ie("wc_sessionSettle",c,a==null?void 0:a.id),h=await this.client.core.crypto.encode(t,d,{encoding:pe});this.client.core.history.set(t,d),await this.client.core.relayer.publishCustom({payload:{sessionTopic:t,pairingTopic:n.pairingTopic,sessionProposalResponse:o,sessionSettlementRequest:h},opts:C(P({},a),{publishMethod:"wc_approveSession"})})}),p(this,"sendResult",async e=>{const{id:t,topic:s,result:n,throwOnFailedPublish:c,encodeOpts:a,appLink:l}=e,o=Nt(t,n);let d;const h=l&&typeof(global==null?void 0:global.Linking)<"u";try{const f=h?Ne:pe;d=await this.client.core.crypto.encode(s,o,C(P({},a||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),f}let y,u;try{y=await this.client.core.history.get(s,t);const f=y.request;try{u=this.getTVFParams(t,f.params,n)}catch(m){this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m==null?void 0:m.message}`)}}catch(f){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),f}if(h){const f=Ve(l,s,d);await global.Linking.openURL(f,this.client.name)}else{const f=y.request.method,m=D[f].res;m.tvf=C(P({},u),{correlationId:t}),c?(m.internal=C(P({},m.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,d,m)):this.client.core.relayer.publish(s,d,m).catch(g=>this.client.logger.error(g))}await this.client.core.history.resolve(o)}),p(this,"sendError",async e=>{const{id:t,topic:s,error:n,encodeOpts:c,rpcOpts:a,appLink:l}=e,o=Ms(t,n);let d;const h=l&&typeof(global==null?void 0:global.Linking)<"u";try{const u=h?Ne:pe;d=await this.client.core.crypto.encode(s,o,C(P({},c||{}),{encoding:u}))}catch(u){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),u}let y;try{y=await this.client.core.history.get(s,t)}catch(u){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),u}if(h){const u=Ve(l,s,d);await global.Linking.openURL(u,this.client.name)}else{const u=y.request.method,f=a||D[u].res;this.client.core.relayer.publish(s,d,f)}await this.client.core.history.resolve(o)}),p(this,"cleanup",async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let n=!1;ve(s.expiry)&&(n=!0),this.client.core.crypto.keychain.has(s.topic)||(n=!0),n&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{ve(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])}),p(this,"onProviderMessageEvent",async e=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(e):await this.onRelayMessage(e)}),p(this,"onRelayEventRequest",async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()}),p(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===Z.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=Z.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=Z.idle}),p(this,"processRequest",async e=>{const{topic:t,payload:s,attestation:n,transportType:c,encryptedId:a}=e,l=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:l}))switch(l){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:n,encryptedId:a});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:n,encryptedId:a,transportType:c});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:n,encryptedId:a,transportType:c});default:return this.client.logger.info(`Unsupported request method ${l}`)}}),p(this,"onRelayEventResponse",async e=>{const{topic:t,payload:s,transportType:n}=e,c=(await this.client.core.history.get(t,s.id)).request.method;switch(c){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,n);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${c}`)}}),p(this,"onRelayEventUnknownPayload",e=>{const{topic:t}=e,{message:s}=I("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),p(this,"shouldIgnorePairingRequest",e=>{const{topic:t,requestMethod:s}=e,n=this.expectedPairingMethodMap.get(t);return!n||n.includes(s)?!1:!!(n.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),p(this,"onSessionProposeRequest",async e=>{const{topic:t,payload:s,attestation:n,encryptedId:c}=e,{params:a,id:l}=s;try{const o=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),o==null||o.setError(Ds.proposal_listener_not_found)),this.isValidConnect(P({},s.params));const d=a.expiryTimestamp||K(D.wc_sessionPropose.req.ttl),h=P({id:l,pairingTopic:t,expiryTimestamp:d,attestation:n,encryptedId:c},a);await this.setProposal(l,h);const y=await this.getVerifyContext({attestationId:n,hash:se(JSON.stringify(s)),encryptedId:c,metadata:h.proposer.metadata});o==null||o.addTrace(Cs.emit_session_proposal),this.client.events.emit("session_proposal",{id:l,params:h,verifyContext:y})}catch(o){await this.sendError({id:l,topic:t,error:o,rpcOpts:D.wc_sessionPropose.autoReject}),this.client.logger.error(o)}}),p(this,"onSessionProposeResponse",async(e,t,s)=>{const{id:n}=t;if(re(t)){const{result:c}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:c});const a=this.client.proposal.get(n);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:a});const l=a.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:l});const o=c.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:o});const d=await this.client.core.crypto.generateSharedKey(l,o);this.pendingSessions.set(n,{sessionTopic:d,pairingTopic:e,proposalId:n,publicKey:l});const h=await this.client.core.relayer.subscribe(d,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else if(ne(t)){await this.deleteProposal(n);const c=O("session_connect",n);if(this.events.listenerCount(c)===0)throw new Error(`emitting ${c} without any listeners, 954`);this.events.emit(c,{error:t.error})}}),p(this,"onSessionSettleRequest",async(e,t)=>{const{id:s,params:n}=t;try{this.isValidSessionSettleRequest(n);const{relay:c,controller:a,expiry:l,namespaces:o,sessionProperties:d,scopedProperties:h,sessionConfig:y,proposalRequestsResponses:u}=t.params,f=[...this.pendingSessions.values()].find(_=>_.sessionTopic===e);if(!f)return this.client.logger.error(`Pending session not found for topic ${e}`);const m=this.client.proposal.get(f.proposalId),g=C(P(P(P({topic:e,relay:c,expiry:l,namespaces:o,acknowledged:!0,pairingTopic:f.pairingTopic,requiredNamespaces:m.requiredNamespaces,optionalNamespaces:m.optionalNamespaces,controller:a.publicKey,self:{publicKey:f.publicKey,metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},d&&{sessionProperties:d}),h&&{scopedProperties:h}),y&&{sessionConfig:y}),{transportType:k.relay,authentication:u==null?void 0:u.authentication,walletPayResult:u==null?void 0:u.walletPay});await this.client.session.set(g.topic,g),await this.setExpiry(g.topic,g.expiry),await this.client.core.pairing.updateMetadata({topic:f.pairingTopic,metadata:g.peer.metadata}),this.pendingSessions.delete(f.proposalId),this.deleteProposal(f.proposalId,!1),this.cleanupDuplicatePairings(g),await this.sendResult({id:t.id,topic:e,throwOnFailedPublish:!0,result:!0}),this.client.events.emit("session_connect",{session:g}),this.events.emit(O("session_connect",f.proposalId),{session:g})}catch(c){await this.sendError({id:s,topic:e,error:c}),this.client.logger.error(c)}}),p(this,"onSessionSettleResponse",async(e,t)=>{const{id:s}=t;re(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(O("session_approve",s),{})):ne(t)&&(await this.client.session.delete(e,Q("USER_DISCONNECTED")),this.events.emit(O("session_approve",s),{error:t.error}))}),p(this,"onSessionUpdateRequest",async(e,t)=>{const{params:s,id:n}=t;try{const c=`${e}_session_update`,a=Le.get(c);if(a&&this.isRequestOutOfSync(a,n)){this.client.logger.warn(`Discarding out of sync request - ${n}`),this.sendError({id:n,topic:e,error:Q("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(P({topic:e},s));try{Le.set(c,n),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:n,topic:e,result:!0})}catch(l){throw Le.delete(c),l}this.client.events.emit("session_update",{id:n,topic:e,params:s})}catch(c){await this.sendError({id:n,topic:e,error:c}),this.client.logger.error(c)}}),p(this,"isRequestOutOfSync",(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3)),p(this,"onSessionUpdateResponse",(e,t)=>{const{id:s}=t,n=O("session_update",s);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);re(t)?this.events.emit(O("session_update",s),{}):ne(t)&&this.events.emit(O("session_update",s),{error:t.error})}),p(this,"onSessionExtendRequest",async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,K(Se)),await this.sendResult({id:s,topic:e,result:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),p(this,"onSessionExtendResponse",(e,t)=>{const{id:s}=t,n=O("session_extend",s);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);re(t)?this.events.emit(O("session_extend",s),{}):ne(t)&&this.events.emit(O("session_extend",s),{error:t.error})}),p(this,"onSessionPingRequest",async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),p(this,"onSessionPingResponse",(e,t)=>{const{id:s}=t,n=O("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners 2176`);re(t)?this.events.emit(O("session_ping",s),{}):ne(t)&&this.events.emit(O("session_ping",s),{error:t.error})},500)}),p(this,"onSessionDeleteRequest",async(e,t)=>{const{id:s}=t;try{await this.isValidDisconnect({topic:e,reason:t.params}),this.cleanupPendingSentRequestsForTopic({topic:e,error:Q("USER_DISCONNECTED")}),await this.deleteSession({topic:e,id:s})}catch(n){this.client.logger.error(n)}}),p(this,"onSessionRequest",async e=>{var t,s,n;const{topic:c,payload:a,attestation:l,encryptedId:o,transportType:d}=e,{id:h,params:y}=a;try{await this.isValidRequest(P({topic:c},y));const u=this.client.session.get(c),f=await this.getVerifyContext({attestationId:l,hash:se(JSON.stringify(Ie("wc_sessionRequest",y,h))),encryptedId:o,metadata:u.peer.metadata,transportType:d}),m={id:h,topic:c,params:y,verifyContext:f};await this.setPendingSessionRequest(m),d===k.link_mode&&(t=u.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=u.peer.metadata.redirect)==null?void 0:s.universal),(n=this.client.signConfig)!=null&&n.disableRequestQueue?this.emitSessionRequest(m):(this.addSessionRequestToSessionRequestQueue(m),this.processSessionRequestQueue())}catch(u){await this.sendError({id:h,topic:c,error:u}),this.client.logger.error(u)}}),p(this,"onSessionRequestResponse",(e,t)=>{const{id:s}=t,n=O("session_request",s);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);re(t)?this.events.emit(O("session_request",s),{result:t.result}):ne(t)&&this.events.emit(O("session_request",s),{error:t.error})}),p(this,"onSessionEventRequest",async(e,t)=>{const{id:s,params:n}=t;try{const c=`${e}_session_event_${n.event.name}`,a=Le.get(c);if(a&&this.isRequestOutOfSync(a,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(P({topic:e},n)),this.client.events.emit("session_event",{id:s,topic:e,params:n}),Le.set(c,s)}catch(c){await this.sendError({id:s,topic:e,error:c}),this.client.logger.error(c)}}),p(this,"onSessionAuthenticateResponse",(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),re(t)?this.events.emit(O("session_request",s),{result:t.result}):ne(t)&&this.events.emit(O("session_request",s),{error:t.error})}),p(this,"onSessionAuthenticateRequest",async e=>{var t;const{topic:s,payload:n,attestation:c,encryptedId:a,transportType:l}=e;try{const{requester:o,authPayload:d,expiryTimestamp:h}=n.params,y=await this.getVerifyContext({attestationId:c,hash:se(JSON.stringify(n)),encryptedId:a,metadata:o.metadata,transportType:l}),u={requester:o,pairingTopic:s,id:n.id,authPayload:d,verifyContext:y,expiryTimestamp:h};await this.setAuthRequest(n.id,{request:u,pairingTopic:s,transportType:l}),l===k.link_mode&&(t=o.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(o.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:n.params,id:n.id,verifyContext:y})}catch(o){this.client.logger.error(o);const d=n.params.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),y=this.getAppLinkIfEnabled(n.params.requester.metadata,l),u={type:Ze,receiverPublicKey:d,senderPublicKey:h};await this.sendError({id:n.id,topic:s,error:o,encodeOpts:u,rpcOpts:D.wc_sessionAuthenticate.autoReject,appLink:y})}}),p(this,"addSessionRequestToSessionRequestQueue",e=>{this.sessionRequestQueue.queue.push(e)}),p(this,"cleanupAfterResponse",e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=Z.idle,this.processSessionRequestQueue()},q.toMiliseconds(this.requestQueueDelay))}),p(this,"cleanupPendingSentRequestsForTopic",({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(n=>n.topic===e&&n.request.method==="wc_sessionRequest").forEach(n=>{this.events.emit(O("session_request",n.request.id),{error:t})})}),p(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===Z.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}}),p(this,"emitSessionRequest",e=>{if(this.emittedSessionRequests.has(e.id)){this.client.logger.warn({id:e.id},`Skipping emitting \`session_request\` event for duplicate request. id: ${e.id}`);return}this.sessionRequestQueue.state=Z.active,this.emittedSessionRequests.add(e.id),this.client.events.emit("session_request",e)}),p(this,"onPairingCreated",e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:Ie("wc_sessionPropose",C(P({},t),{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties,scopedProperties:t.scopedProperties}),t.id),attestation:t.attestation,encryptedId:t.encryptedId})}),p(this,"isValidConnect",async e=>{if(!J(e)){const{message:o}=I("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(o)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:n,sessionProperties:c,scopedProperties:a,relays:l}=e;if(ge(t)||await this.isValidPairingTopic(t),!Vs(l)){const{message:o}=I("MISSING_OR_INVALID",`connect() relays: ${l}`);throw new Error(o)}if(s&&!ge(s)&&At(s)!==0){const o="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(o):this.client.logger.warn(o),this.validateNamespaces(s,"requiredNamespaces")}if(n&&!ge(n)&&At(n)!==0&&this.validateNamespaces(n,"optionalNamespaces"),c&&!ge(c)&&this.validateSessionProps(c,"sessionProperties"),a&&!ge(a)){this.validateSessionProps(a,"scopedProperties");const o=Object.keys(s||{}).concat(Object.keys(n||{}));if(!Object.keys(a).every(d=>o.includes(d.split(":")[0])))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(o)}`)}}),p(this,"validateNamespaces",(e,t)=>{const s=$s(e,"connect()",t);if(s)throw new Error(s.message)}),p(this,"isValidApprove",async e=>{if(!J(e))throw new Error(I("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:n,sessionProperties:c,scopedProperties:a}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const l=this.client.proposal.get(t),o=et(s,"approve()");if(o)throw new Error(o.message);const d=Lt(l.requiredNamespaces,s,"approve()");if(d)throw new Error(d.message);if(!he(n,!0)){const{message:h}=I("MISSING_OR_INVALID",`approve() relayProtocol: ${n}`);throw new Error(h)}if(c&&!ge(c)&&this.validateSessionProps(c,"sessionProperties"),a&&!ge(a)){this.validateSessionProps(a,"scopedProperties");const h=new Set(Object.keys(s));if(!Object.keys(a).every(y=>h.has(y.split(":")[0])))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(h).join(", ")}`)}}),p(this,"isValidReject",async e=>{if(!J(e)){const{message:n}=I("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(n)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!js(s)){const{message:n}=I("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(n)}}),p(this,"isValidSessionSettleRequest",e=>{if(!J(e)){const{message:o}=I("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(o)}const{relay:t,controller:s,namespaces:n,expiry:c}=e;if(!Us(t)){const{message:o}=I("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(o)}const a=Ws(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const l=et(n,"onSessionSettleRequest()");if(l)throw new Error(l.message);if(ve(c)){const{message:o}=I("EXPIRED","onSessionSettleRequest()");throw new Error(o)}}),p(this,"isValidUpdate",async e=>{if(!J(e)){const{message:l}=I("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(l)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const n=this.client.session.get(t),c=et(s,"update()");if(c)throw new Error(c.message);const a=Lt(n.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)}),p(this,"isValidExtend",async e=>{if(!J(e)){const{message:s}=I("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)}),p(this,"isValidRequest",async e=>{if(!J(e)){const{message:l}=I("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(l)}const{topic:t,request:s,chainId:n,expiry:c}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:a}=this.client.session.get(t);if(!xt(a,n)){const{message:l}=I("MISSING_OR_INVALID",`request() chainId: ${n}`);throw new Error(l)}if(!Ks(s)){const{message:l}=I("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(l)}if(!zs(a,n,s.method)){const{message:l}=I("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(l)}this.validateRequestExpiry(c)}),p(this,"isValidRespond",async e=>{var t;if(!J(e)){const{message:a}=I("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(a)}const{topic:s,response:n}=e;try{await this.isValidSessionTopic(s)}catch(a){throw(t=e==null?void 0:e.response)!=null&&t.id&&this.cleanupAfterResponse(e),a}if(!Fs(n)){const{message:a}=I("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(n)}`);throw new Error(a)}const c=this.client.pendingRequest.get(n.id);if(c.topic!==s){const{message:a}=I("MISMATCHED_TOPIC",`Request response topic mismatch. reqId: ${n.id}, expected topic: ${c.topic}, received topic: ${s}`);throw new Error(a)}}),p(this,"isValidPing",async e=>{if(!J(e)){const{message:s}=I("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),p(this,"isValidEmit",async e=>{if(!J(e)){const{message:a}=I("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(a)}const{topic:t,event:s,chainId:n}=e;await this.isValidSessionTopic(t);const{namespaces:c}=this.client.session.get(t);if(!xt(c,n)){const{message:a}=I("MISSING_OR_INVALID",`emit() chainId: ${n}`);throw new Error(a)}if(!Gs(s)){const{message:a}=I("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!Qs(c,n,s.name)){const{message:a}=I("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}}),p(this,"isValidDisconnect",async e=>{if(!J(e)){const{message:s}=I("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),p(this,"isValidAuthenticate",e=>{const{chains:t,uri:s,domain:n,nonce:c}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!he(s,!1))throw new Error("uri is required parameter");if(!he(n,!1))throw new Error("domain is required parameter");if(!he(c,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(l=>Ye(l).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=Ye(t[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),p(this,"getVerifyContext",async e=>{const{attestationId:t,hash:s,encryptedId:n,metadata:c,transportType:a}=e,l={verified:{verifyUrl:c.verifyUrl||Js,validation:"UNKNOWN",origin:c.url||""}};try{if(a===k.link_mode){const d=this.getAppLinkIfEnabled(c,a);return l.verified.validation=d&&new URL(d).origin===new URL(c.url).origin?"VALID":"INVALID",l}const o=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:n,verifyUrl:c.verifyUrl});o&&(l.verified.origin=o.origin,l.verified.isScam=o.isScam,l.verified.validation=o.origin===new URL(c.url).origin?"VALID":"INVALID")}catch(o){this.client.logger.warn(o)}return this.client.logger.debug(`Verify context: ${JSON.stringify(l)}`),l}),p(this,"validateSessionProps",(e,t)=>{Object.values(e).forEach((s,n)=>{if(s==null){const{message:c}=I("MISSING_OR_INVALID",`${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[n]}`);throw new Error(c)}})}),p(this,"getPendingAuthRequest",e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0}),p(this,"addToRecentlyDeleted",(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const n=this.recentlyDeletedLimit/2;for(const c of this.recentlyDeletedMap.keys()){if(s++>=n)break;this.recentlyDeletedMap.delete(c)}}}),p(this,"checkRecentlyDeleted",e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=I("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}}),p(this,"isLinkModeEnabled",(e,t)=>{var s,n,c,a,l,o,d,h,y;return!e||t!==k.link_mode?!1:((n=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:n.linkMode)===!0&&((a=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:a.universal)!==void 0&&((o=(l=this.client.metadata)==null?void 0:l.redirect)==null?void 0:o.universal)!==""&&((d=e==null?void 0:e.redirect)==null?void 0:d.universal)!==void 0&&((h=e==null?void 0:e.redirect)==null?void 0:h.universal)!==""&&((y=e==null?void 0:e.redirect)==null?void 0:y.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),p(this,"getAppLinkIfEnabled",(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e==null?void 0:e.redirect)==null?void 0:s.universal:void 0}),p(this,"handleLinkModeMessage",({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=kt(e,"topic")||"",s=decodeURIComponent(kt(e,"wc_ev")||""),n=this.client.session.keys.includes(t);n&&this.client.session.update(t,{transportType:k.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:n})}),p(this,"registerLinkModeListeners",async()=>{var e;if(Bs()||Hs()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),p(this,"getTVFApproveParams",e=>{try{const t=Ys(e.namespaces),s=Xs(e.namespaces),n=Zs(e.namespaces),c=e.sessionProperties,a=e.scopedProperties;return{approvedChains:t,approvedMethods:s,approvedEvents:n,sessionProperties:c,scopedProperties:a}}catch(t){return this.client.logger.warn(t,"Error getting TVF approve params"),{}}}),p(this,"getTVFParams",(e,t,s)=>{var n,c,a;if(!((n=t.request)!=null&&n.method))return{};const l={correlationId:e,rpcMethods:[t.request.method],chainId:t.chainId};try{const o=this.extractTxHashesFromResult(t.request,s);l.txHashes=o,l.contractAddresses=this.isValidContractData(t.request.params)?[(a=(c=t.request.params)==null?void 0:c[0])==null?void 0:a.to]:[]}catch(o){this.client.logger.warn(o,"Error getting TVF params")}return l}),p(this,"isValidContractData",e=>{var t;if(!e)return!1;try{const s=(e==null?void 0:e.data)||((t=e==null?void 0:e[0])==null?void 0:t.data);if(!s.startsWith("0x"))return!1;const n=s.slice(2);return/^[0-9a-fA-F]*$/.test(n)?n.length%2===0:!1}catch{}return!1}),p(this,"extractTxHashesFromResult",(e,t)=>{var s;try{if(!t)return[];const n=e.method,c=Bi[n];if(n==="sui_signTransaction")return[ei(t.transactionBytes)];if(n==="near_signTransaction")return[Mt(t)];if(n==="near_signTransactions")return t.map(l=>Mt(l));if(n==="xrpl_signTransactionFor"||n==="xrpl_signTransaction")return[(s=t.tx_json)==null?void 0:s.hash];if(n==="polkadot_signTransaction")return[ti({transaction:e.params.transactionPayload,signature:t.signature})];if(n==="algo_signTxn")return Ct(t)?t.map(l=>Dt(l)):[Dt(t)];if(n==="cosmos_signDirect")return[si(t)];if(n==="wallet_sendCalls")return ii(t);if(typeof t=="string")return[t];const a=t[c.key];if(Ct(a))return n==="solana_signAllTransactions"?a.map(l=>ri(l)):a;if(typeof a=="string")return[a]}catch(n){this.client.logger.warn(n,"Error extracting tx hashes from result")}return[]})}async processPendingMessageEvents(){try{const r=this.client.session.keys,e=this.client.core.relayer.messages.getWithoutAck(r);for(const[t,s]of Object.entries(e))for(const n of s)try{await this.onProviderMessageEvent({topic:t,message:n,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${n}`)}}catch(r){this.client.logger.warn(r,"processPendingMessageEvents failed")}}isInitialized(){if(!this.initialized){const{message:r}=I("NOT_INITIALIZED",this.name);throw new Error(r)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(vs.message,r=>{this.onProviderMessageEvent(r)})}async onRelayMessage(r){const{topic:e,message:t,attestation:s,transportType:n}=r,{publicKey:c}=this.client.auth.authKeys.keys.includes(Ke)?this.client.auth.authKeys.get(Ke):{publicKey:void 0};try{const a=await this.client.core.crypto.decode(e,t,{receiverPublicKey:c,encoding:n===k.link_mode?Ne:pe});_s(a)?(this.client.core.history.set(e,a),await this.onRelayEventRequest({topic:e,payload:a,attestation:s,transportType:n,encryptedId:se(t)})):Is(a)?(await this.client.core.history.resolve(a),await this.onRelayEventResponse({topic:e,payload:a,transportType:n}),this.client.core.history.delete(e,a.id)):(this.client.logger.error(`onRelayMessage() -> unknown payload: ${JSON.stringify(a)}`),await this.onRelayEventUnknownPayload({topic:e,payload:a,transportType:n})),await this.client.core.relayer.messages.ack(e,t)}catch(a){this.client.logger.error(`onRelayMessage() -> failed to process an inbound message: ${t}`),this.client.logger.error(a)}}registerExpirerEvents(){this.client.core.expirer.on(Es.expired,async r=>{const{topic:e,id:t}=Ss(r.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,I("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,I("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(St.create,r=>this.onPairingCreated(r)),this.client.core.pairing.events.on(St.delete,r=>{this.addToRecentlyDeleted(r.topic,"pairing")})}isValidPairingTopic(r){if(!he(r,!1)){const{message:e}=I("MISSING_OR_INVALID",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=I("NO_MATCHING_KEY",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(ve(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=I("EXPIRED",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!he(r,!1)){const{message:e}=I("MISSING_OR_INVALID",`session topic should be a string: ${r}`);throw new Error(e)}if(this.checkRecentlyDeleted(r),!this.client.session.keys.includes(r)){const{message:e}=I("NO_MATCHING_KEY",`session topic doesn't exist: ${r}`);throw new Error(e)}if(ve(this.client.session.get(r).expiry)){await this.deleteSession({topic:r});const{message:e}=I("EXPIRED",`session topic: ${r}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(r)){const{message:e}=I("MISSING_OR_INVALID",`session topic does not exist in keychain: ${r}`);throw await this.deleteSession({topic:r}),new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.checkRecentlyDeleted(r),this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(he(r,!1)){const{message:e}=I("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else{const{message:e}=I("MISSING_OR_INVALID",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!bs(r)){const{message:e}=I("MISSING_OR_INVALID",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=I("NO_MATCHING_KEY",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(ve(this.client.proposal.get(r).expiryTimestamp)){await this.deleteProposal(r);const{message:e}=I("EXPIRED",`proposal id: ${r}`);throw new Error(e)}}validateRequestExpiry(r){if(r&&!Rs(r,nt)){const{message:e}=I("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${nt.min} and ${nt.max}`);throw new Error(e)}}}class lr extends qe{constructor(r,e){super(r,e,Gi,ft),this.core=r,this.logger=e}}class pr extends qe{constructor(r,e){super(r,e,Qi,ft),this.core=r,this.logger=e}}class hr extends qe{constructor(r,e){super(r,e,Hi,ft,t=>t.id),this.core=r,this.logger=e}}class dr extends qe{constructor(r,e){super(r,e,er,Fe,()=>Ke),this.core=r,this.logger=e}}class ur extends qe{constructor(r,e){super(r,e,tr,Fe),this.core=r,this.logger=e}}class gr extends qe{constructor(r,e){super(r,e,sr,Fe,t=>t.id),this.core=r,this.logger=e}}var mr=Object.defineProperty,yr=(i,r,e)=>r in i?mr(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,at=(i,r,e)=>yr(i,typeof r!="symbol"?r+"":r,e);class fr{constructor(r,e){this.core=r,this.logger=e,at(this,"authKeys"),at(this,"pairingTopics"),at(this,"requests"),this.authKeys=new dr(this.core,this.logger),this.pairingTopics=new ur(this.core,this.logger),this.requests=new gr(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var wr=Object.defineProperty,vr=(i,r,e)=>r in i?wr(i,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[r]=e,b=(i,r,e)=>vr(i,typeof r!="symbol"?r+"":r,e);class os extends hs{constructor(r){super(r),b(this,"protocol",rs),b(this,"version",ns),b(this,"name",rt.name),b(this,"metadata"),b(this,"core"),b(this,"logger"),b(this,"events",new ds.EventEmitter),b(this,"engine"),b(this,"session"),b(this,"proposal"),b(this,"pendingRequest"),b(this,"auth"),b(this,"signConfig"),b(this,"on",(t,s)=>this.events.on(t,s)),b(this,"once",(t,s)=>this.events.once(t,s)),b(this,"off",(t,s)=>this.events.off(t,s)),b(this,"removeListener",(t,s)=>this.events.removeListener(t,s)),b(this,"removeAllListeners",t=>this.events.removeAllListeners(t)),b(this,"connect",async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"pair",async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"approve",async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"reject",async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"update",async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"extend",async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"request",async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"respond",async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"ping",async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"emit",async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"disconnect",async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"find",t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}}),b(this,"authenticate",async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(n){throw this.logger.error(n.message),n}}),b(this,"formatAuthMessage",t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"approveSessionAuthenticate",async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),b(this,"rejectSessionAuthenticate",async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),this.name=(r==null?void 0:r.name)||rt.name,this.metadata=us(r==null?void 0:r.metadata),this.signConfig=r==null?void 0:r.signConfig;const e=gs({logger:(r==null?void 0:r.logger)||rt.logger,name:this.name});this.logger=e,this.core=(r==null?void 0:r.core)||new ms(r),this.session=new pr(this.core,this.logger),this.proposal=new lr(this.core,this.logger),this.pendingRequest=new hr(this.core,this.logger),this.engine=new cr(this),this.auth=new fr(this.core,this.logger)}static async init(r){const e=new os(r);return await e.initialize(),e}get context(){return Fi(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success")}catch(r){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(r.message),r}}}export{j as C,Ir as E,st as M,B as O,ts as R,Jt as T,Sr as W,Re as a,Er as b,mi as c,os as q};
